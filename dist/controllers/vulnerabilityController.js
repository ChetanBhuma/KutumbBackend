"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulnerabilityController = void 0;
const vulnerabilityService_1 = require("../services/vulnerabilityService");
const database_1 = require("../config/database");
const errorHandler_1 = require("../middleware/errorHandler");
const fetchCitizensForScoring = async () => {
    return await database_1.prisma.seniorCitizen.findMany({
        where: { isActive: true },
        select: {
            id: true,
            fullName: true,
            healthConditions: true,
            physicalDisability: true,
            mobilityStatus: true,
            livingArrangement: true,
            registeredOnApp: true,
            isMobileRegistered: true,
            lastVisitDate: true,
            vulnerabilityScore: true,
            vulnerabilityLevel: true,
            _count: {
                select: {
                    HouseholdHelp: true,
                    FamilyMember: true
                }
            }
        }
    });
};
const mapConfig = (config) => {
    const weights = (0, vulnerabilityService_1.normalizeWeights)(config.weights);
    const bands = (config.bands || []).map((band) => ({
        id: band.id,
        name: band.name,
        label: band.label,
        min: band.min,
        max: band.max,
        color: band.color || '#64748b',
        visitFrequencyDays: band.visitFrequencyDays
    })).sort((a, b) => a.min - b.min);
    return {
        id: config.id,
        version: config.version,
        weights,
        bands,
        isActive: config.isActive,
        createdAt: config.createdAt,
        createdBy: config.createdById || null,
        createdByName: config.createdByName || 'System',
        publishedAt: config.publishedAt,
        publishedBy: config.publishedById,
        publishedByName: config.publishedByName,
        notes: config.notes
    };
};
const evaluateCitizens = (citizens, weights, bands) => {
    const distribution = { low: 0, medium: 0, high: 0 };
    const evaluations = citizens.map((citizen) => {
        const factors = (0, vulnerabilityService_1.calculateFactors)(citizen);
        const score = (0, vulnerabilityService_1.calculateScore)(factors, weights);
        const band = (0, vulnerabilityService_1.getBandForScore)(score, bands);
        const bandName = band.name || 'low';
        distribution[bandName] = (distribution[bandName] || 0) + 1;
        return {
            citizenId: citizen.id,
            score,
            band: bandName,
            bandLabel: band.label
        };
    });
    return { evaluations, distribution };
};
const calculateVisitFrequencyImpact = (distribution, bands) => {
    const bandFreq = new Map();
    bands.forEach((band) => bandFreq.set(band.name, band.visitFrequencyDays || 30));
    const dailyVisits = vulnerabilityService_1.BAND_NAMES.reduce((sum, name) => {
        const freq = bandFreq.get(name) || 30;
        const citizens = distribution[name] || 0;
        return sum + citizens / freq;
    }, 0);
    return {
        dailyVisits: Math.round(dailyVisits),
        weeklyVisits: Math.round(dailyVisits * 7),
        monthlyVisits: Math.round(dailyVisits * 30)
    };
};
const calculateImpact = async (weights, bands) => {
    await (0, vulnerabilityService_1.ensureDefaultConfig)();
    const activeConfig = await database_1.prisma.vulnerabilityConfig.findFirst({
        where: { isActive: true },
        orderBy: { version: 'desc' },
        include: { bands: true }
    });
    if (!activeConfig) {
        throw new errorHandler_1.AppError('Active configuration not found', 404);
    }
    const citizens = await fetchCitizensForScoring();
    const activeWeights = (0, vulnerabilityService_1.normalizeWeights)(activeConfig.weights);
    const activeBands = (0, vulnerabilityService_1.normalizeBands)(activeConfig.bands);
    const currentEval = evaluateCitizens(citizens, activeWeights, activeBands);
    const projectedEval = evaluateCitizens(citizens, weights, bands);
    const impact = {
        totalCitizens: citizens.length,
        currentDistribution: currentEval.distribution,
        projectedDistribution: projectedEval.distribution,
        changes: {
            low: projectedEval.distribution.low - currentEval.distribution.low,
            medium: projectedEval.distribution.medium - currentEval.distribution.medium,
            high: projectedEval.distribution.high - currentEval.distribution.high
        },
        visitFrequencyImpact: calculateVisitFrequencyImpact(projectedEval.distribution, bands)
    };
    return { impact, citizens, evaluations: projectedEval.evaluations };
};
const updateCitizenScores = async (evaluations) => {
    const now = new Date();
    const chunkSize = 50;
    for (let i = 0; i < evaluations.length; i += chunkSize) {
        const chunk = evaluations.slice(i, i + chunkSize);
        await database_1.prisma.$transaction(chunk.map((evaluation) => database_1.prisma.seniorCitizen.update({
            where: { id: evaluation.citizenId },
            data: {
                vulnerabilityScore: evaluation.score,
                vulnerabilityLevel: evaluation.bandLabel,
                lastAssessmentDate: now
            }
        })));
    }
};
const validateWeights = (weights) => {
    const total = Object.values(weights).reduce((sum, value) => sum + value, 0);
    if (total !== 100) {
        throw new errorHandler_1.AppError('Weights must sum to 100%', 400);
    }
};
const validateBands = (bands) => {
    if (bands.length === 0) {
        throw new errorHandler_1.AppError('At least one band configuration is required', 400);
    }
    const sorted = [...bands].sort((a, b) => a.min - b.min);
    if (sorted[0].min !== 0 || sorted[sorted.length - 1].max !== 100) {
        throw new errorHandler_1.AppError('Bands must cover the range 0-100', 400);
    }
    const names = new Set();
    sorted.forEach((band, index) => {
        if (!vulnerabilityService_1.BAND_NAMES.includes(band.name)) {
            throw new errorHandler_1.AppError(`Invalid band name: ${band.name}`, 400);
        }
        if (names.has(band.name)) {
            throw new errorHandler_1.AppError(`Duplicate band name: ${band.name}`, 400);
        }
        names.add(band.name);
        if (band.min > band.max) {
            throw new errorHandler_1.AppError(`Band ${band.label} has invalid range`, 400);
        }
        if (index > 0 && band.min !== sorted[index - 1].max + 1) {
            throw new errorHandler_1.AppError('Band ranges must be contiguous', 400);
        }
    });
};
class VulnerabilityController {
    static async getConfig(_req, res, next) {
        try {
            await (0, vulnerabilityService_1.ensureDefaultConfig)();
            const config = await database_1.prisma.vulnerabilityConfig.findFirst({
                where: { isActive: true },
                orderBy: { version: 'desc' },
                include: { bands: true }
            });
            if (!config) {
                throw new errorHandler_1.AppError('Configuration not found', 404);
            }
            res.json({
                success: true,
                data: {
                    config: mapConfig(config)
                }
            });
        }
        catch (error) {
            next(error);
        }
    }
    static async getHistory(_req, res, next) {
        try {
            await (0, vulnerabilityService_1.ensureDefaultConfig)();
            const history = await database_1.prisma.vulnerabilityConfig.findMany({
                orderBy: { version: 'desc' },
                include: { bands: true },
                take: 10
            });
            res.json({
                success: true,
                data: {
                    history: history.map(mapConfig)
                }
            });
        }
        catch (error) {
            next(error);
        }
    }
    static async preview(req, res, next) {
        try {
            const weights = (0, vulnerabilityService_1.normalizeWeights)(req.body?.weights);
            const bands = (0, vulnerabilityService_1.normalizeBands)(req.body?.bands);
            validateWeights(weights);
            validateBands(bands);
            const { impact } = await calculateImpact(weights, bands);
            res.json({
                success: true,
                data: { impact }
            });
        }
        catch (error) {
            next(error);
        }
    }
    static async save(req, res, next) {
        try {
            if (!req.user) {
                throw new errorHandler_1.AppError('Authentication required', 401);
            }
            const weights = (0, vulnerabilityService_1.normalizeWeights)(req.body?.weights);
            const bands = (0, vulnerabilityService_1.normalizeBands)(req.body?.bands);
            const notes = req.body?.notes || null;
            validateWeights(weights);
            validateBands(bands);
            await (0, vulnerabilityService_1.ensureDefaultConfig)();
            const lastConfig = await database_1.prisma.vulnerabilityConfig.findFirst({
                orderBy: { version: 'desc' }
            });
            const newVersion = (lastConfig?.version || 0) + 1;
            const { impact, evaluations } = await calculateImpact(weights, bands);
            await database_1.prisma.$transaction(async (tx) => {
                await tx.vulnerabilityConfig.updateMany({
                    where: { isActive: true },
                    data: { isActive: false }
                });
                await tx.vulnerabilityConfig.create({
                    data: {
                        version: newVersion,
                        weights,
                        isActive: true,
                        notes,
                        createdById: req.user?.id,
                        createdByName: req.user?.email || req.user?.id,
                        publishedAt: new Date(),
                        publishedById: req.user?.id,
                        publishedByName: req.user?.email || req.user?.id,
                        bands: {
                            create: bands.map((band) => ({
                                name: band.name,
                                label: band.label,
                                min: band.min,
                                max: band.max,
                                color: band.color,
                                visitFrequencyDays: band.visitFrequencyDays
                            }))
                        }
                    }
                });
            });
            await updateCitizenScores(evaluations);
            const [activeConfig, history] = await Promise.all([
                database_1.prisma.vulnerabilityConfig.findFirst({
                    where: { isActive: true },
                    orderBy: { version: 'desc' },
                    include: { bands: true }
                }),
                database_1.prisma.vulnerabilityConfig.findMany({
                    orderBy: { version: 'desc' },
                    include: { bands: true },
                    take: 10
                })
            ]);
            res.json({
                success: true,
                data: {
                    config: activeConfig ? mapConfig(activeConfig) : null,
                    history: history.map(mapConfig),
                    impact
                },
                message: 'Vulnerability configuration updated'
            });
        }
        catch (error) {
            next(error);
        }
    }
}
exports.VulnerabilityController = VulnerabilityController;
//# sourceMappingURL=vulnerabilityController.js.map