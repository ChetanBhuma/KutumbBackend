import {
    calculateFactors,
    calculateScore,
    getBandForScore,
    normalizeWeights,
    normalizeBands,
    ensureDefaultConfig,
    VulnerabilityWeights,
    VulnerabilityBandInput,
    recalculateVulnerability,
    CitizenForScoring,
    Evaluation,
    BAND_NAMES
} from '../services/vulnerabilityService';
import { prisma } from '../config/database';
import { AppError } from '../middleware/errorHandler';
import { AuthRequest } from '../middleware/authenticate';
import { Request, Response, NextFunction } from 'express';

const fetchCitizensForScoring = async (): Promise<CitizenForScoring[]> => {
    return await prisma.seniorCitizen.findMany({
        where: { isActive: true },
        select: {
            id: true,
            fullName: true,
            healthConditions: true,
            physicalDisability: true,
            mobilityStatus: true,
            livingArrangement: true,
            registeredOnApp: true,
            isMobileRegistered: true,
            lastVisitDate: true,
            vulnerabilityScore: true,
            vulnerabilityLevel: true,
            _count: {
                select: {
                    HouseholdHelp: true,
                    FamilyMember: true
                }
            }
        }
    }) as unknown as CitizenForScoring[];
};

const mapConfig = (config: any) => {
    const weights = normalizeWeights(config.weights as any);
    const bands = (config.bands || []).map((band: any) => ({
        id: band.id,
        name: band.name as 'low' | 'medium' | 'high',
        label: band.label,
        min: band.min,
        max: band.max,
        color: band.color || '#64748b',
        visitFrequencyDays: band.visitFrequencyDays
    })).sort((a: any, b: any) => a.min - b.min);

    return {
        id: config.id,
        version: config.version,
        weights,
        bands,
        isActive: config.isActive,
        createdAt: config.createdAt,
        createdBy: config.createdById || null,
        createdByName: config.createdByName || 'System',
        publishedAt: config.publishedAt,
        publishedBy: config.publishedById,
        publishedByName: config.publishedByName,
        notes: config.notes
    };
};


const evaluateCitizens = (
    citizens: CitizenForScoring[],
    weights: VulnerabilityWeights,
    bands: VulnerabilityBandInput[]
) => {
    const distribution: Record<'low' | 'medium' | 'high', number> = { low: 0, medium: 0, high: 0 };
    const evaluations: Evaluation[] = citizens.map((citizen) => {
        const factors = calculateFactors(citizen);
        const score = calculateScore(factors, weights);
        const band = getBandForScore(score, bands);
        const bandName = (band.name as 'low' | 'medium' | 'high') || 'low';
        distribution[bandName] = (distribution[bandName] || 0) + 1;

        return {
            citizenId: citizen.id,
            score,
            band: bandName,
            bandLabel: band.label
        };
    });

    return { evaluations, distribution };
};

const calculateVisitFrequencyImpact = (
    distribution: Record<'low' | 'medium' | 'high', number>,
    bands: VulnerabilityBandInput[]
) => {
    const bandFreq = new Map<string, number>();
    bands.forEach((band) => bandFreq.set(band.name, band.visitFrequencyDays || 30));

    const dailyVisits = BAND_NAMES.reduce((sum, name) => {
        const freq = bandFreq.get(name) || 30;
        const citizens = distribution[name as 'low' | 'medium' | 'high'] || 0;
        return sum + citizens / freq;
    }, 0);

    return {
        dailyVisits: Math.round(dailyVisits),
        weeklyVisits: Math.round(dailyVisits * 7),
        monthlyVisits: Math.round(dailyVisits * 30)
    };
};

const calculateImpact = async (
    weights: VulnerabilityWeights,
    bands: VulnerabilityBandInput[]
) => {
    await ensureDefaultConfig();
    const activeConfig = await prisma.vulnerabilityConfig.findFirst({
        where: { isActive: true },
        orderBy: { version: 'desc' },
        include: { bands: true }
    });

    if (!activeConfig) {
        throw new AppError('Active configuration not found', 404);
    }

    const citizens = await fetchCitizensForScoring();
    const activeWeights = normalizeWeights(activeConfig.weights as any);
    const activeBands = normalizeBands(activeConfig.bands as any);

    const currentEval = evaluateCitizens(citizens, activeWeights, activeBands);
    const projectedEval = evaluateCitizens(citizens, weights, bands);

    const impact = {
        totalCitizens: citizens.length,
        currentDistribution: currentEval.distribution,
        projectedDistribution: projectedEval.distribution,
        changes: {
            low: projectedEval.distribution.low - currentEval.distribution.low,
            medium: projectedEval.distribution.medium - currentEval.distribution.medium,
            high: projectedEval.distribution.high - currentEval.distribution.high
        },
        visitFrequencyImpact: calculateVisitFrequencyImpact(projectedEval.distribution, bands)
    };

    return { impact, citizens, evaluations: projectedEval.evaluations };
};

const updateCitizenScores = async (evaluations: Evaluation[]) => {
    const now = new Date();
    const chunkSize = 50;
    for (let i = 0; i < evaluations.length; i += chunkSize) {
        const chunk = evaluations.slice(i, i + chunkSize);
        await prisma.$transaction(
            chunk.map((evaluation) =>
                prisma.seniorCitizen.update({
                    where: { id: evaluation.citizenId },
                    data: {
                        vulnerabilityScore: evaluation.score,
                        vulnerabilityLevel: evaluation.bandLabel,
                        lastAssessmentDate: now
                    }
                })
            )
        );
    }
};

const validateWeights = (weights: VulnerabilityWeights) => {
    const total = Object.values(weights).reduce((sum, value) => sum + value, 0);
    if (total !== 100) {
        throw new AppError('Weights must sum to 100%', 400);
    }
};

const validateBands = (bands: VulnerabilityBandInput[]) => {
    if (bands.length === 0) {
        throw new AppError('At least one band configuration is required', 400);
    }

    const sorted = [...bands].sort((a, b) => a.min - b.min);
    if (sorted[0].min !== 0 || sorted[sorted.length - 1].max !== 100) {
        throw new AppError('Bands must cover the range 0-100', 400);
    }

    const names = new Set<string>();
    sorted.forEach((band, index) => {
        if (!BAND_NAMES.includes(band.name as string)) {
            throw new AppError(`Invalid band name: ${band.name}`, 400);
        }
        if (names.has(band.name)) {
            throw new AppError(`Duplicate band name: ${band.name}`, 400);
        }
        names.add(band.name);

        if (band.min > band.max) {
            throw new AppError(`Band ${band.label} has invalid range`, 400);
        }

        if (index > 0 && band.min !== sorted[index - 1].max + 1) {
            throw new AppError('Band ranges must be contiguous', 400);
        }
    });
};

export class VulnerabilityController {
    static async getConfig(_req: Request, res: Response, next: NextFunction) {
        try {
            await ensureDefaultConfig();
            const config = await prisma.vulnerabilityConfig.findFirst({
                where: { isActive: true },
                orderBy: { version: 'desc' },
                include: { bands: true }
            });

            if (!config) {
                throw new AppError('Configuration not found', 404);
            }

            res.json({
                success: true,
                data: {
                    config: mapConfig(config)
                }
            });
        } catch (error) {
            next(error);
        }
    }

    static async getHistory(_req: Request, res: Response, next: NextFunction) {
        try {
            await ensureDefaultConfig();
            const history = await prisma.vulnerabilityConfig.findMany({
                orderBy: { version: 'desc' },
                include: { bands: true },
                take: 10
            });

            res.json({
                success: true,
                data: {
                    history: history.map(mapConfig)
                }
            });
        } catch (error) {
            next(error);
        }
    }

    static async preview(req: AuthRequest, res: Response, next: NextFunction) {
        try {
            const weights = normalizeWeights(req.body?.weights);
            const bands = normalizeBands(req.body?.bands);
            validateWeights(weights);
            validateBands(bands);

            const { impact } = await calculateImpact(weights, bands);

            res.json({
                success: true,
                data: { impact }
            });
        } catch (error) {
            next(error);
        }
    }

    static async save(req: AuthRequest, res: Response, next: NextFunction) {
        try {
            if (!req.user) {
                throw new AppError('Authentication required', 401);
            }

            const weights = normalizeWeights(req.body?.weights);
            const bands = normalizeBands(req.body?.bands);
            const notes = req.body?.notes || null;

            validateWeights(weights);
            validateBands(bands);

            await ensureDefaultConfig();
            const lastConfig = await prisma.vulnerabilityConfig.findFirst({
                orderBy: { version: 'desc' }
            });
            const newVersion = (lastConfig?.version || 0) + 1;

            const { impact, evaluations } = await calculateImpact(weights, bands);

            await prisma.$transaction(async (tx) => {
                await tx.vulnerabilityConfig.updateMany({
                    where: { isActive: true },
                    data: { isActive: false }
                });

                await tx.vulnerabilityConfig.create({
                    data: {
                        version: newVersion,
                        weights,
                        isActive: true,
                        notes,
                        createdById: req.user?.id,
                        createdByName: req.user?.email || req.user?.id,
                        publishedAt: new Date(),
                        publishedById: req.user?.id,
                        publishedByName: req.user?.email || req.user?.id,
                        bands: {
                            create: bands.map((band) => ({
                                name: band.name,
                                label: band.label,
                                min: band.min,
                                max: band.max,
                                color: band.color,
                                visitFrequencyDays: band.visitFrequencyDays
                            }))
                        }
                    }
                });
            });

            await updateCitizenScores(evaluations);

            const [activeConfig, history] = await Promise.all([
                prisma.vulnerabilityConfig.findFirst({
                    where: { isActive: true },
                    orderBy: { version: 'desc' },
                    include: { bands: true }
                }),
                prisma.vulnerabilityConfig.findMany({
                    orderBy: { version: 'desc' },
                    include: { bands: true },
                    take: 10
                })
            ]);

            res.json({
                success: true,
                data: {
                    config: activeConfig ? mapConfig(activeConfig) : null,
                    history: history.map(mapConfig),
                    impact
                },
                message: 'Vulnerability configuration updated'
            });
        } catch (error) {
            next(error);
        }
    }
}
