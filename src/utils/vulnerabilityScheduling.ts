import { prisma } from '../config/database';
import { auditLogger } from '../config/logger';

/**
 * Calculate visit frequency based on vulnerability score
 */
const getVisitFrequency = (vulnerabilityLevel: string): number => {
    switch (vulnerabilityLevel) {
        case 'High':
            return 3; // 3 days (twice weekly)
        case 'Medium':
            return 7; // 7 days (weekly)
        case 'Low':
        default:
            return 30; // 30 days (monthly)
    }
};

/**
 * Auto-schedule visits based on citizen vulnerability
 */
export const scheduleVulnerabilityBasedVisits = async () => {
    try {
        // Get all active citizens with vulnerability assessments
        const citizens = await prisma.seniorCitizen.findMany({
            where: {
                isActive: true,
                idVerificationStatus: 'Verified',
                beatId: { not: null }
            },
            include: {
                VulnerabilityHistory: {
                    orderBy: { createdAt: 'desc' },
                    take: 1
                },
                Beat: {
                    include: {
                        BeatOfficer: {
                            where: { isActive: true },
                            take: 1
                        }
                    }
                },
                Visit: {
                    where: {
                        status: { in: ['SCHEDULED', 'IN_PROGRESS'] }
                    }
                }
            }
        });

        let scheduledCount = 0;

        for (const citizen of citizens) {
            // Skip if no vulnerability assessment or no officer
            if (!citizen.VulnerabilityHistory[0] || !citizen.Beat?.BeatOfficer[0]) {
                continue;
            }

            // Skip if already has scheduled visit
            if (citizen.Visit.length > 0) {
                continue;
            }

            const assessment = citizen.VulnerabilityHistory[0];
            const officer = citizen.Beat.BeatOfficer[0];
            const frequencyDays = getVisitFrequency(assessment.level);

            // Calculate next visit date
            const lastVisit = await prisma.visit.findFirst({
                where: {
                    seniorCitizenId: citizen.id,
                    status: 'COMPLETED'
                },
                orderBy: { completedDate: 'desc' }
            });

            const lastVisitDate = lastVisit?.completedDate || new Date();
            const daysSinceLastVisit = Math.floor(
                (Date.now() - lastVisitDate.getTime()) / (1000 * 60 * 60 * 24)
            );

            // Schedule if due
            if (daysSinceLastVisit >= frequencyDays) {
                const scheduledDate = new Date();
                scheduledDate.setDate(scheduledDate.getDate() + 1); // Next day
                scheduledDate.setHours(10, 0, 0, 0); // 10 AM

                await prisma.visit.create({
                    data: {
                        seniorCitizenId: citizen.id,
                        officerId: officer.id,
                        policeStationId: citizen.policeStationId || officer.policeStationId || '',
                        beatId: citizen.beatId,
                        visitType: 'Routine',
                        scheduledDate,
                        status: 'SCHEDULED'
                    }
                });

                scheduledCount++;
            }
        }

        auditLogger.info('Vulnerability-based visits scheduled', {
            totalCitizensChecked: citizens.length,
            scheduledCount
        });

        return { scheduledCount };
    } catch (error) {
        auditLogger.error('Failed to schedule vulnerability-based visits', { error });
        throw error;
    }
};
